# %% graveyard

        # ### calculate optim variables    
        # swarm_w_prev = default_w # used to calc optim variables
        # comp_w = swarm_w[0] # arbitrary
        
        # ## B_j, need magnitude
        # mag_B_j = 0
        # for i in default_w.keys():
        #     mag_B_j += torch.norm(1/lr*default_w[i] - 1/lr*comp_w[i])
            
        #     grad_diffs[0].append(1/lr*default_w[i] - 1/lr*comp_w[i])
        #     grad_diffs[1].append(1/lr*default_w[i] - 1/lr*swarm_w[1][i])
            
        # print(mag_B_j)
        # mu_j = 0
        # mu_j_grad = 0
        # mu_j_params = 0
        # for i in default_w.keys():
        #     mu_j_grad += torch.norm(1/lr * comp_w[i] - 1/lr * swarm_w[1][i])
        #     mu_j_params += torch.norm(comp_w[ )
        
    
        # B_j = [i - swarm_w] 


#### HN-PFL procedure 
### 1. create object for each node/device
### 2. after \tau1 = swarm_period iterations, aggregate cluster-wise (weighed)
### 3. after \tau2 = global_period swarm-wide aggregations, aggregate globally (unweighted)

# print('HN-PFL begins here')

# uav_counter = 0
# for ind_i,val_i in enumerate(nodes_per_cluster):
#     for j in range(val_i): # each uav in i
#         local_obj = LocalUpdate_PFL(device,bs=10,lr=lr,epochs=swarm_period,\
#                 dataset=dataset_train,indexes=static_nts[uav_counter])
#         _,w,loss = local_obj.train(net=deepcopy(pfl_swarm_models[ind_i]).to(device))
        
#         swarm_w[ind_i].append(w)
        
#         uav_counter += 1





        # ## final instance for localized gradient descents
        # print('final iteration - localized only')        
        # swarm_w = {i:[] for i in range(settings.swarms)}
        
        # uav_counter = 0
        # for ind_i,val_i in enumerate(nodes_per_swarm):
        #     for j in range(val_i): # each uav in i
        #         if settings.online == False:
        #             local_obj = LocalUpdate(device,bs=batch_size,lr=lr,epochs=1,\
        #                     dataset=dataset_train,indexes=node_train_sets[uav_counter])
        #         else:
        #             local_obj = LocalUpdate(device,bs=batch_size,lr=lr,epochs=1,\
        #                     dataset=dataset_train,indexes=node_train_sets[t][uav_counter])
                
        #         _,w,loss = local_obj.train(net=deepcopy(fl_swarm_models[ind_i]).to(device))
                
        #         swarm_w[ind_i].append(w)
                
        #         uav_counter += 1
        
        # ## run FL swarm-wide aggregation only
        # if settings.online == False:
        #     temp_qty = deepcopy(data_qty).tolist()
        # else:
        #     temp_qty = 0*data_qty[t]
        #     for t_prime in range(swarm_period*global_period):
        #         temp_qty += data_qty[t-t_prime]
        #     temp_qty = temp_qty.tolist()
            
        # for ind_i,val_i in enumerate(nodes_per_swarm):
        #     t2_static_qty = temp_qty[:val_i]
        #     del temp_qty[:val_i]
            
        #     t3_static_qty = [i*swarm_period for i in t2_static_qty]
            
        #     w_avg_swarm = FedAvg2(swarm_w[ind_i],t3_static_qty)

        #     fl_swarm_models[ind_i].load_state_dict(w_avg_swarm)
        #     fl_swarm_models[ind_i].train()
        
        # fl_acc_temp = 0
        # total_loss_temp = 0
        
        # for i,ii in enumerate(fl_swarm_models):
        #     ii.eval()
        #     temp_acc, loss = test_img2(ii,dataset_test,bs=batch_size,\
        #             indexes=swarm_test_sets[i],device=device)
            
        #     fl_acc_temp += temp_acc/len(fl_swarm_models)
        #     total_loss_temp += loss/len(fl_swarm_models) #swarms

        # fl_acc.append(fl_acc_temp)
        # total_loss.append(total_loss_temp)





                # # swarm-wide agg
                # if settings.online == False:
                #     temp_qty = deepcopy(data_qty).tolist() # TODO: readjust debug flag later
                # else:
                #     temp_qty = 0*data_qty[t]
                #     for t_prime in range(swarm_period*global_period):
                #         temp_qty += data_qty[t-t_prime]
                #     temp_qty = temp_qty.tolist()
                    
                # t_swarm_total_qty = []
                # w_swarms = []
                
                # for ind_i,val_i in enumerate(nodes_per_swarm):
                #     t2_static_qty = temp_qty[:val_i]
                #     del temp_qty[:val_i]
                    
                #     t3_static_qty = [i*swarm_period for i in t2_static_qty]

                #     w_avg_swarm = FedAvg2(swarm_w[ind_i],t3_static_qty)
                    
                #     t_swarm_total_qty.append(sum(t3_static_qty))
                #     w_swarms.append(w_avg_swarm)
				
# %% graveyard

        # ### calculate optim variables    
        # swarm_w_prev = default_w # used to calc optim variables
        # comp_w = swarm_w[0] # arbitrary
        
        # ## B_j, need magnitude
        # mag_B_j = 0
        # for i in default_w.keys():
        #     mag_B_j += torch.norm(1/lr*default_w[i] - 1/lr*comp_w[i])
            
        #     grad_diffs[0].append(1/lr*default_w[i] - 1/lr*comp_w[i])
        #     grad_diffs[1].append(1/lr*default_w[i] - 1/lr*swarm_w[1][i])
            
        # print(mag_B_j)
        # mu_j = 0
        # mu_j_grad = 0
        # mu_j_params = 0
        # for i in default_w.keys():
        #     mu_j_grad += torch.norm(1/lr * comp_w[i] - 1/lr * swarm_w[1][i])
        #     mu_j_params += torch.norm(comp_w[ )
        
    
        # B_j = [i - swarm_w] 


#### HN-PFL procedure 
### 1. create object for each node/device
### 2. after \tau1 = swarm_period iterations, aggregate cluster-wise (weighed)
### 3. after \tau2 = global_period swarm-wide aggregations, aggregate globally (unweighted)

# print('HN-PFL begins here')

# uav_counter = 0
# for ind_i,val_i in enumerate(nodes_per_cluster):
#     for j in range(val_i): # each uav in i
#         local_obj = LocalUpdate_PFL(device,bs=10,lr=lr,epochs=swarm_period,\
#                 dataset=dataset_train,indexes=static_nts[uav_counter])
#         _,w,loss = local_obj.train(net=deepcopy(pfl_swarm_models[ind_i]).to(device))
        
#         swarm_w[ind_i].append(w)
        
#         uav_counter += 1

## calculating final localized accuracy
            # swarm_w = {i:[] for i in range(settings.swarms)}
            
            # uav_counter = 0
            # for ind_i,val_i in enumerate(nodes_per_swarm):
            #     for j in range(val_i): # each uav in i
            #         if settings.online == False:
            #             local_obj = LocalUpdate_HF_PFL(device,bs=batch_size,lr1=lr,lr2=lr2,epochs=1,\
            #                     dataset=dataset_train,indexes=node_train_sets[uav_counter])
            #         else:
            #             local_obj = LocalUpdate_HF_PFL(device,bs=batch_size,lr1=lr,lr2=lr2,epochs=1,\
            #                     dataset=dataset_train,indexes=node_train_sets[t][uav_counter])
                    
            #         _,w,loss = local_obj.train(net=deepcopy(HF_hn_pfl_swarm_models[ind_i]).to(device))
                    
            #         swarm_w[ind_i].append(w)
                    
            #         uav_counter += 1
            
            # ## run FL swarm-wide aggregation only
            # if settings.online == False:
            #     temp_qty = deepcopy(data_qty).tolist()
            # else:
            #     temp_qty = 0*data_qty[t]
            #     for t_prime in range(swarm_period*global_period):
            #         temp_qty += data_qty[t-t_prime]
            #     temp_qty = temp_qty.tolist()
                
            # for ind_i,val_i in enumerate(nodes_per_swarm):
            #     t2_static_qty = temp_qty[:val_i]
            #     del temp_qty[:val_i]
                
            #     t3_static_qty = [i*swarm_period for i in t2_static_qty]
                
            #     w_avg_swarm = FedAvg2(swarm_w[ind_i],t3_static_qty)
    
            #     HF_hn_pfl_swarm_models[ind_i].load_state_dict(w_avg_swarm)
            #     HF_hn_pfl_swarm_models[ind_i].train()


                # # swarm-wide agg
                # if settings.online == False:
                #     temp_qty = deepcopy(data_qty).tolist()
                # else:
                #     temp_qty = 0*data_qty[t]
                #     for t_prime in range(swarm_period*global_period):
                #         temp_qty += data_qty[t-t_prime]
                #     temp_qty = temp_qty.tolist()
                    
                # t_swarm_total_qty = []
                # w_swarms = []
                
                # for ind_i,val_i in enumerate(nodes_per_swarm):
                #     t2_static_qty = temp_qty[:val_i]
                #     del temp_qty[:val_i]
                    
                #     t3_static_qty = [i*swarm_period for i in t2_static_qty]

                #     w_avg_swarm = FedAvg2(swarm_w[ind_i],t3_static_qty)
                    
                #     t_swarm_total_qty.append(sum(t3_static_qty))
                #     w_swarms.append(w_avg_swarm)



                # if settings.online == False:
                #     temp_qty = deepcopy(data_qty).tolist()
                # else:
                #     temp_qty = 0*data_qty[t]
                #     for t_prime in range(swarm_period*global_period):
                #         temp_qty += data_qty[t-t_prime]
                #     temp_qty = temp_qty.tolist()
                    
                # for ind_i,val_i in enumerate(nodes_per_swarm):
                #     t2_static_qty = temp_qty[:val_i]
                #     del temp_qty[:val_i]
                    
                #     t3_static_qty = [i*swarm_period for i in t2_static_qty]
                    
                #     w_avg_swarm = FedAvg2(swarm_w[ind_i],t3_static_qty)
        
                #     HF_hn_pfl_swarm_models[ind_i].load_state_dict(w_avg_swarm)
                #     HF_hn_pfl_swarm_models[ind_i].train()				
				
				
# %%
# total_fl_ratios = []
# total_pfl_ratios = []

# for ratio in [1,2,4]:
#     # ratio = 1 #, taus1,taus2 = 1,2,2
#     ## reload data
#     total_fl_accs, total_pfl_accs = [], []
#     global_period = 1
#     swarm_period = ratio*global_period
#     for iid_style in ['extreme','mild']: #,'iid']: #crashed on frankie for some reason...; wtf ,'extreme'
        
#         with open(data_loc+'fl_acc_'+iid_style+'_'+str(ratio)+'_'+data_source \
#                   +'_'+str(swarm_period)+'_'+str(global_period),'rb') as f:
#             fl_acc = pk.load(f)
        
#         with open(data_loc+'hn_pfl_acc_'+iid_style+'_'+str(ratio)+'_'+data_source \
#                    +'_'+str(swarm_period)+'_'+str(global_period),'rb') as f:
#             pfl_acc = pk.load(f)
        
#         total_fl_accs.append(fl_acc)
#         total_pfl_accs.append(pfl_acc)
    
#     total_fl_ratios.append(total_fl_accs)
#     total_pfl_ratios.append(total_pfl_accs)
    
# plt.figure(2)
# f2,ax2 = plt.subplots(1,2,figsize=(10,4),dpi=100,sharey=True)

# ind = 0
# for i in range(3):
#     if i == 0:
#         temp_indexes = np.arange(0,120,step=1) #total_fl_ratios[i][0]
#     elif i == 1:
#         temp_indexes = np.arange(0,120,step=2)
#     else:
#         temp_indexes = np.arange(0,120,step=4)
    
#     ax2[ind].plot(temp_indexes,total_fl_ratios[i][0],label='fl_acc',\
#         marker='x',color='forestgreen',linestyle='dashed')
#     ax2[ind].plot(temp_indexes,total_pfl_ratios[i][0],label='pfl acc',\
#         marker='o',color='darkblue',linestyle='dashed')
    
            
# ax2[ind].set_title('extreme non-i.i.d')


# ind = 1
# for i in range(3):
#     if i == 0:
#         temp_indexes = np.arange(0,120,step=1) #total_fl_ratios[i][0]
#     elif i == 1:
#         temp_indexes = np.arange(0,120,step=2)
#     else:
#         temp_indexes = np.arange(0,120,step=4)
    
#     ax2[ind].plot(temp_indexes,total_fl_ratios[i][ind],label='fl_acc',\
#         marker='x',color='forestgreen',linestyle='dashed')
#     ax2[ind].plot(temp_indexes,total_pfl_ratios[i][ind],label='pfl acc',\
#         marker='o',color='darkblue',linestyle='dashed')
    
            
# ax2[ind].set_title('moderate non-i.i.d')
# # ax[ind].set_title('moderate non-i.i.d')
# # ax[ind].legend()

### Personalized plotter
# ind = 0
# for i in range(len(ratio_vec)): #3
#     if i == 0:
#         temp_indexes = np.arange(0,40,step=1) #total_fl_ratios[i][0]
#     elif i == 1:
#         temp_indexes = np.arange(0,40,step=2)
#     else:
#         temp_indexes = np.arange(0,40,step=4)
#     temp_indexes = np.arange(0,40,step=ratio_vec[i])
    
#     # temp_indexes = np.arange(0,40,step=1)
    
#     # temp_indexes2 = list(temp_indexes)
#     # temp_indexes2.append(40)
#     # temp_indexes = temp_indexes2

#     if i == 0:
#         ax2[ind].plot(temp_indexes,total_fl_ratios[i][0],\
#             label='H-FL '+r'$\tau_{s}^{\mathsf{L}} = 1$ '+ r'$\tau_{s}^{\mathsf{G}} = 1$',\
#             color='forestgreen',linestyle='solid')
#         ax2[ind].plot(temp_indexes,total_pfl_ratios[i][0],\
#             label='HN-PFL '+r'$\tau_{s}^{\mathsf{L}} = 1$ '+ r'$\tau_{s}^{\mathsf{G}} = 1$',\
#             color='darkblue',linestyle='solid')
#     elif i == 1:
#         ax2[ind].plot(temp_indexes,total_fl_ratios[i][0],\
#             label='H-FL '+r'$\tau_{s}^{\mathsf{L}} = 1$ '+ r'$\tau_{s}^{\mathsf{G}} = 2$',\
#             color='forestgreen',linestyle='dashed')
#         ax2[ind].plot(temp_indexes,total_pfl_ratios[i][0],\
#             label='HN-PFL '+r'$\tau_{s}^{\mathsf{L}} = 1$ '+ r'$\tau_{s}^{\mathsf{G}} = 2$',\
#             color='darkblue',linestyle='dashed')
#     elif i == 2:
#         ax2[ind].plot(temp_indexes,total_fl_ratios[i][0],\
#             label='H-FL '+r'$\tau_{s}^{\mathsf{L}} = 1$ '+ r'$\tau_{s}^{\mathsf{G}} = 4$',\
#             color='forestgreen',linestyle='dotted')
#         ax2[ind].plot(temp_indexes,total_pfl_ratios[i][0],\
#             label='HN-PFL '+r'$\tau_{s}^{\mathsf{L}} = 1$ '+ r'$\tau_{s}^{\mathsf{G}} = 4$',\
#             color='darkblue',linestyle='dotted')
#     else:
#         ax2[ind].plot(temp_indexes,total_fl_ratios[i][0],\
#             label='H-FL '+r'$\tau_{s}^{\mathsf{L}} = 1$ '+ r'$\tau_{s}^{\mathsf{G}} = 8$',\
#             color='forestgreen',linestyle='dashdot')
#         ax2[ind].plot(temp_indexes,total_pfl_ratios[i][0],\
#             label='HN-PFL '+r'$\tau_{s}^{\mathsf{L}} = 1$ '+ r'$\tau_{s}^{\mathsf{G}} = 8$',\
#             color='darkblue',linestyle='dashdot')
    
# ax2[ind].set_title(data_source.upper()+' Performance Accuracy Personalized')
# ax2[ind].set_ylabel('Accuracy (%)')
# ax2[ind].set_xlabel('Local Iteration')
# ax2[ind].grid(True)
# ax2[ind].legend()

# # %% plot 1 fl vs pfl extreme nonidd comparison
# # static ratio - 1,1 at taus1=taus2=2
# ratio = 1 #, taus1,taus2 = 1,2,2
# ## reload data
# total_fl_accs, total_pfl_accs = [], []
# swarm_period, global_period = 2,2
# for iid_style in ['extreme','mild','iid']: #crashed on frankie for some reason...; wtf ,'extreme'
    
#     with open(data_loc+'fl_acc_'+iid_style+'_'+str(ratio)+'_'+data_source \
#               +'_'+str(swarm_period)+'_'+str(global_period),'rb') as f:
#         fl_acc = pk.load(f)
    
#     with open(data_loc+'hn_pfl_acc_'+iid_style+'_'+str(ratio)+'_'+data_source \
#                +'_'+str(swarm_period)+'_'+str(global_period),'rb') as f:
#         pfl_acc = pk.load(f)
    
#     total_fl_accs.append(fl_acc)
#     total_pfl_accs.append(pfl_acc)


# ## subplots method with iid, mild, extreme 
# plt.figure(1)
# f,ax = plt.subplots(1,3,figsize=(10,4),dpi=100,sharey=True)

# ind = 0 #[1:20]; [:19]
# ax[ind].plot(total_fl_accs[ind],label='fl_acc',marker='x',color='forestgreen',linestyle='dashed')
# ax[ind].plot(total_pfl_accs[ind],label='pfl acc',marker='o',color='darkblue',linestyle='dashed')
# ax[ind].set_title('extreme non-i.i.d')
# # ax[ind].legend()

# ind = 1
# ax[ind].plot(total_fl_accs[ind],label='fl_acc',marker='x',color='forestgreen',linestyle='dashed')
# ax[ind].plot(total_pfl_accs[ind],label='pfl acc',marker='o',color='darkblue',linestyle='dashed')
# ax[ind].set_title('moderate non-i.i.d')
# # ax[ind].legend()

# ind = 2
# ax[ind].plot(total_fl_accs[ind],label='fl_acc',marker='x',color='forestgreen',linestyle='dashed')
# ax[ind].plot(total_pfl_accs[ind],label='pfl acc',marker='o',color='darkblue',linestyle='dashed')
# ax[ind].set_title('i.i.d')
# # ax[ind].legend()

# for i in range(3):
#     if i == 0:
#         ax[i].set_ylabel('Accuracy(%)',fontsize=12,**csfont)
    
#     ax[i].set_xlabel('Global Aggregation ($k_s^{\mathsf{G}}$)', fontsize=11, **csfont)
#     ax[i].set_axisbelow(True)
#     ax[i].grid(True)

# h,l = ax[0].get_legend_handles_labels()
# kw = dict(ncol=2,loc = 'lower center',frameon=False)
# #(x, y, width, height)
# leg1 = ax[0].legend(h[:],l[:],bbox_to_anchor=(0.8,1.05,1.5,0.2),\
#                        mode='expand',fontsize='large',**kw)
    
# ax[0].add_artist(leg1)
# plt.subplots_adjust(top=0.8,wspace=0.05,hspace=0.15)

# # plt.savefig(str(data_source)+'2_2_ratio_1.png',dpi=500)				